


#include "qpcpp.h"
#include "game.h"
#include "bsp.h"

// #include "qwin_gui.h"  // QWIN GUI
#include "resource.h"  // GUI resource IDs generated by the resource editior

#include <stdio.h>     // for _snprintf_s()
#include <stdlib.h>

#ifdef Q_SPY
#define WIN32_LEAN_AND_MEAN
#include <windows.h>  // Win32 API for multithreading
#include <winsock2.h> // for Windows network facilities
#endif

Q_DEFINE_THIS_FILE
// local variables -----------------------------------------------------------
static HINSTANCE l_hInst;             // this GAME instance
static HWND      l_hWnd;              // main window handle
static LPSTR     l_cmdLine;           // the command line string


#ifdef Q_SPY
enum QSUserRecords {
    PLAYER_TRIGGER = QP::QS_USER,
    COMMAND_STAT
};
static SOCKET l_sock = INVALID_SOCKET;
 
static uint8_t const l_mouse = 0U;
#endif

#ifdef Q_SPY
#define WIN32_LEAN_AND_MEAN
#include <windows.h>  // Win32 API for multithreading
#include <winsock2.h> // for Windows network facilities
#endif

///***************************************************************************
// thread function for running the GAME main() -- GUI main thread
static DWORD WINAPI appThread (LPVOID par) {
    (void)par;         // unused parameter
    return main_gui (); // run the QF GAME
}

//............................................................................
//............................................................................
extern "C" int WINAPI WinMain (HINSTANCE hInst, HINSTANCE /*hPrevInst*/,
    LPSTR cmdLine, int iCmdShow)
{
    l_hInst = hInst;   // save the GAME instance
    l_cmdLine = cmdLine; // save the command line string

                         // create the main custom dialog window
    HWND hWnd = CreateCustDialog (hInst, IDD_APPLICATION, NULL,
        &WndProc, "QP_APP");
    ShowWindow (hWnd, iCmdShow); // show the main window

                                 // enter the message loop...
    MSG msg;
    while (GetMessage (&msg, NULL, 0, 0)) {
        TranslateMessage (&msg);
        DispatchMessage (&msg);
    }

    BSP_terminate (0);

    return msg.wParam;
}
//............................................................................
static LRESULT CALLBACK WndProc (HWND hWnd, UINT iMsg,
    WPARAM wParam, LPARAM lParam)
{
    switch (iMsg) {

        // Perform initialization upon cration of the main dialog window
        // NOTE: Any child-windows are NOT created yet at this time, so
        // the GetDlgItem() function can't be used (it will return NULL).
        //
    case WM_CREATE: {
        l_hWnd = hWnd; // save the window handle


        return 0;
    }

                    // Perform initialization after all child windows have been created
    case WM_INITDIALOG: {

        // --> QP: spawn the GAME thread to run main_gui()
        Q_ALLEGE (CreateThread (NULL, 0, &appThread, NULL, 0, NULL)
            != (HANDLE)0);
        return 0;
    }

    case WM_DESTROY: {
        OutputDebugString ("DESTROY\n");
        PostQuitMessage (0);
        return 0;
    }

                     // commands from regular buttons and menus...
    case WM_COMMAND: {
        SetFocus (hWnd);
        switch (wParam) {
        case IDOK:
        case IDCANCEL: {
            OutputDebugString ("QUIT\n");
            PostQuitMessage (0);
            break;
        }
        }
        return 0;
    }

                     // owner-drawn buttons...
    case WM_DRAWITEM: {
        LPDRAWITEMSTRUCT pdis = (LPDRAWITEMSTRUCT)lParam;
        switch (pdis->CtlID) {
        case IDC_USER0: {  // USER owner-drawn Button0
            OutputDebugString ("USER0\n");

            switch (OwnerDrawnButton_draw (&l_userBtn0, pdis)) {
            case BTN_DEPRESSED: {
                playerTrigger ();
                break;
            }
            case BTN_RELEASED: {
                break;
            }
            default: {
                break;
            }
            }
            break;
        }
        case IDC_USER1: {  // USER owner-drawn Button1
            OutputDebugString ("USER1\n");
            switch (OwnerDrawnButton_draw (&l_userBtn1, pdis)) {
            default: {
                break;
            }
            }
            break;
        }
        }
        return 0;
    }

                      // mouse wheel input...
    case WM_MOUSEWHEEL: {
        OutputDebugString ("MOUSEWHEEL\n");
        return 0;
    }

                        // keyboard input...
    case WM_KEYDOWN: {
        OutputDebugString ("KEYDOWN\n");
        switch (wParam) {
        case VK_SPACE:
            playerTrigger ();

            break;
        }
    case VK_NUMPAD0: {
        break;

    }
                     // ...

                     return 0;
    }

    case WM_KEYUP: {
        OutputDebugString ("KEYUP\n");
        switch (wParam) {
        case VK_SPACE:
            break;
        }
        return 0;
    }
    }
    return DefWindowProc (hWnd, iMsg, wParam, lParam);
}
//..........................................................................*/

//............................................................................
extern "C" void Q_onAssert (char const * const module, int loc) {
    QF::stop ();  // stop ticking
    QS_ASSERTION (module, loc, 10000U); // report assertion to QS

    char message[80];

    // SNPRINTF_S() set and send ,message, to MessageBox()
    SNPRINTF_S (message, Q_DIM (message) - 1,
        "Assertion failed in module %s location %d", module, loc);
    MessageBox (GAME::l_hWnd, message, "!!! ASSERTION !!!",
        MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
    PostQuitMessage (-1);
}

#ifdef Q_SPY  // define QS callbacks

#include <time.h>

// In this demo, the QS software tracing output is sent out of the GAME
// through a TCP/IP socket. This requires the QSPY host GAME to
// be started first to open a server socket (qspy -t ...) to wait for the
// incoming TCP/IP connection from the GAME demo.
//
// In an embedded target, the QS software tracing output can be sent out
// using any method available, such as a UART. This would require changing
// the implementation of the functions in this section, but the rest of the
// GAME code does not "know" (and should not care) how the QS ouptut
// is actually performed. In other words, the rest of the GAME does NOT
// need to change in any way to produce QS output.

//............................................................................
extern "C" DWORD WINAPI idleThread (LPVOID par) { // signature for CreateThread()
    (void)par;
    while (GAME::l_sock != INVALID_SOCKET) {
        uint8_t const *block;

        // try to receive bytes from the QS socket...
        uint16_t nBytes = QS::rxGetNfree ();
        if (nBytes > 0U) {
            uint8_t buf[64];
            int status;

            if (nBytes > sizeof (buf)) {
                nBytes = sizeof (buf);
            }
            status = recv (GAME::l_sock, reinterpret_cast<char *>(&buf[0]),
                static_cast<int>(nBytes), 0);
            if (status != SOCKET_ERROR) {
                uint16_t i;
                nBytes = static_cast<uint16_t>(status);
                for (i = 0U; i < nBytes; ++i) {
                    QS::rxPut (buf[i]);
                }
            }
        }
        QS::rxParse ();  // parse all the received bytes

        nBytes = 1024U;
        QF_CRIT_ENTRY (dummy);
        block = QS::getBlock (&nBytes);
        QF_CRIT_EXIT (dummy);

        if (block != static_cast<uint8_t *>(0)) {
            send (GAME::l_sock, reinterpret_cast<char const *>(block),
                static_cast<int_t>(nBytes), 0);
        }
        Sleep (20); // sleep for xx milliseconds
    }
    return (DWORD)0; // return success
}
//............................................................................
bool QS::onStartup (void const *arg) {
    static uint8_t qsBuf[1024];  // buffer for QS output
    static uint8_t qsRxBuf[100]; // buffer for QS receive channel
    static WSADATA wsaData;
    char hostName[64];
    char const *src;
    char *dst;
    USHORT port = 6601; // default QSPY server port
    ULONG ioctl_opt = 1;
    struct sockaddr_in sockAddr;
    struct hostent *server;

    initBuf (qsBuf, sizeof (qsBuf));
    rxInitBuf (qsRxBuf, sizeof (qsRxBuf));

    // initialize Windows sockets
    if (WSAStartup (MAKEWORD (2, 0), &wsaData) == SOCKET_ERROR) {
        printf ("Windows Sockets cannot be initialized.");
        return (uint8_t)0;
    }

    src = (arg != (void const *)0)
        ? (char const *)arg
        : "localhost";
    dst = hostName;
    while ((*src != '\0')
        && (*src != ':')
        && (dst < &hostName[sizeof (hostName)]))
    {
        *dst++ = *src++;
    }
    *dst = '\0';
    if (*src == ':') {
        port = (USHORT)strtoul (src + 1, NULL, 10);
    }

    GAME::l_sock = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP); // TCP socket
    if (GAME::l_sock == INVALID_SOCKET) {
        printf ("Socket cannot be created; error 0x%08X\n",
            WSAGetLastError ());
        return false; // failure
    }

    server = gethostbyname (hostName);
    if (server == NULL) {
        printf ("QSpy host name %s cannot be resolved; error 0x%08X\n",
            hostName, WSAGetLastError ());
        return false;
    }

    memset (&sockAddr, 0, sizeof (sockAddr));
    sockAddr.sin_family = AF_INET;
    memcpy (&sockAddr.sin_addr, server->h_addr, server->h_length);
    sockAddr.sin_port = htons (port);
    if (connect (GAME::l_sock, reinterpret_cast<struct sockaddr *>(&sockAddr),
        sizeof (sockAddr)) == SOCKET_ERROR)
    {
        printf ("Cannot connect to the QSPY server; error 0x%08X\n",
            WSAGetLastError ());
        QS_EXIT ();
        return false; // failure
    }

    // Set the socket to non-blocking mode.
    if (ioctlsocket (GAME::l_sock, FIONBIO, &ioctl_opt) == SOCKET_ERROR) {
        printf ("Socket configuration failed.\n"
            "Windows socket error 0x%08X.",
            WSAGetLastError ());
        QS_EXIT ();
        return false; // failure
    }

    // set up the QS filters...
    QS_FILTER_ON (QS_QEP_STATE_ENTRY);
    QS_FILTER_ON (QS_QEP_STATE_EXIT);
    QS_FILTER_ON (QS_QEP_STATE_INIT);
    QS_FILTER_ON (QS_QEP_INIT_TRAN);
    QS_FILTER_ON (QS_QEP_INTERN_TRAN);
    QS_FILTER_ON (QS_QEP_TRAN);
    //QS_FILTER_ON(QS_QEP_IGNORED);
    //QS_FILTER_ON(QS_QEP_DISPATCH);
    //QS_FILTER_ON(QS_QEP_UNHANDLED);

    //QS_FILTER_ON(QS_QF_ACTIVE_POST_FIFO);
    //QS_FILTER_ON(QS_QF_ACTIVE_POST_LIFO);
    QS_FILTER_ON (QS_QF_PUBLISH);

    QS_FILTER_ON (GAME::PLAYER_TRIGGER);
    QS_FILTER_ON (GAME::COMMAND_STAT);

    // return the status of creating the idle thread
    return (CreateThread (NULL, 1024, &idleThread, NULL, 0, NULL) != NULL)
        ? true : false;
}
//............................................................................
void QS::onCleanup (void) {
    if (GAME::l_sock != INVALID_SOCKET) {
        closesocket (GAME::l_sock);
        GAME::l_sock = INVALID_SOCKET;
    }
    WSACleanup ();
}
//............................................................................
void QS::onFlush (void) {
    uint16_t nBytes = 1000U;
    uint8_t const *block;
    while ((block = getBlock (&nBytes)) != static_cast<uint8_t *>(0)) {
        send (GAME::l_sock, reinterpret_cast<char const *>(block), nBytes, 0);
        nBytes = 1000U;
    }
}
//............................................................................
QSTimeCtr QS::onGetTime (void) {
    return static_cast<QSTimeCtr>(clock ());
}
//............................................................................
//! callback function to reset the target (to be implemented in the BSP)
void QS::onReset (void) {
    //TBD
}
//............................................................................
//! callback function to execute a uesr command (to be implemented in BSP)
void QS::onCommand (uint8_t cmdId, uint32_t param) {
    (void)cmdId;
    (void)param;
    // GAME-specific record begin
    QS_BEGIN (GAME::COMMAND_STAT, static_cast<void *>(0))
        QS_U8 (2, cmdId);
    QS_U32 (8, param);
    QS_END ()

        if (cmdId == 10U) {
            Q_onAssert ("command", 10);
        }
}

#endif // Q_SPY
